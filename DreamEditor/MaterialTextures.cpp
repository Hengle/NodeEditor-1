#define _CRT_SECURE_NO_WARNINGS
#include "MaterialTextures.h"
#include "Hash.h"
#include <IL\il.h>
#include <IL\ilu.h>
#include <iostream>
#include <iostream>
extern void CheckDevILError();	// Defined in GraphManager.cpp

TextureSlot MaterialTextures::textureSlots[1000];

void MaterialTextures::DeleteTextureResources()
{
	GLuint tempTextures[1000];
	for (unsigned int i = 0; i < 1000; i++)
	{
		// Make a copy of the OGL texture object ID for batch deletion
		tempTextures[i] = textureSlots[i].textureObject;

		// Release memory allocated for strings
		if (textureSlots[i].originalPath != NULL)
		{
			delete textureSlots[i].originalPath;
			textureSlots[i].originalPath = NULL;
		}
	}

	// Then delete all textures at once
	glDeleteTextures(1000, tempTextures);	// opengl silently ignores those names that are 0 or not generated by it
}

// As long as the path is consistent, i.e.either abs or relative, MaterialTexture will make sure there is only one copy created in openGL memory
// Use by Interface Componenets and Phong Shaders; For imagenodes they have their own texture management system through ImageData
GLuint MaterialTextures::GetTexture(const char* texturePath)
{
	// Get the parsed ID of the image path
	unsigned int imageID = Hash::HashID((unsigned char*)texturePath, 1000);
	unsigned int H = imageID;	// As base for quadratic probing

	// For a certain amount of test cases, continuously probing until find an empty slot, remember to mark in between slots "skipped"
	for (unsigned int probeCount = 1; probeCount <= 10; probeCount++)	// Noice we begin with 1 and end with 10
	{
		// 	If the image haven't been loaded, load it
		if (textureSlots[imageID].textureObject == 0)
		{
			// Copy original path
			unsigned int stringSize = strlen(texturePath)*sizeof(char) + 1;
			textureSlots[imageID].originalPath = (char*)malloc(stringSize);
			strcpy(textureSlots[imageID].originalPath, texturePath);
			// textureSlots[imageID].originalPath[stringSize - 1] = 0;	// NULL character already appended by strcpy

			// Generate OpenGL object
			GLuint imageTexture;
			glGenTextures(1, &imageTexture);

			// Open an image using DevIL
			ILuint image; // The image name to return.
			ilGenImages(1, &image); // Grab a new image name.
			ilBindImage(image);
			if (ilLoadImage(texturePath) == IL_FALSE)
			{
				CheckDevILError();
			}
			// Do some error check
			ILint format = ilGetInteger(IL_IMAGE_FORMAT);
			ILint type = ilGetInteger(IL_IMAGE_TYPE);
			if ((format != IL_RGBA && format != IL_RGB) || type != IL_UNSIGNED_BYTE)
			{
				std::cout << "[Error]Texture map is not specified format and type, in " << __FILE__ << " , line " << __LINE__ << std::endl; 	// __DEBUG__: Require better solution
				__debugbreak();
			}

			// Load the image into openGL
			int width = ilGetInteger(IL_IMAGE_WIDTH);
			int height = ilGetInteger(IL_IMAGE_HEIGHT);
			glActiveTexture(GL_TEXTURE0);
			glBindTexture(GL_TEXTURE_2D, imageTexture);
			glTexStorage2D(GL_TEXTURE_2D, 1, (format == IL_RGBA) ? GL_RGBA8 : GL_RGB8, width, height);
			unsigned char* imageData = ilGetData();
			glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, width, height, (format == IL_RGBA) ? GL_RGBA : GL_RGB, GL_UNSIGNED_BYTE, imageData);

			// Set Texture Mipmaps: Not Working, currently the only problem when not using MipMap is the ground looks too sharp in the distant
			//glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_BASE_LEVEL, 0);
			//glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAX_LEVEL, 4);
			//glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
			//glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
			//glGenerateMipmap(GL_TEXTURE_2D);


			// Set Texture Sampling
			//glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
			//glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);

			// Delete the IL image
			ilDeleteImage(image);

			textureSlots[imageID].textureObject = imageTexture;

			// Increate reference count
			textureSlots[imageID].referenceCount++;

			// Return the GLuint objec
			return textureSlots[imageID].textureObject;
		}
		// Collision Resolution using Quadratic probing:
		//	If the slot has already been occupied and that occupant isn't us
		else if (strcmp(textureSlots[imageID].originalPath, texturePath)!= 0)
		{
			// Mark flag
			// Actually we don't need to mark anything since we never unload textures: we either find the slot already occupied and it is not us, or it is us, or it is an empty slot for us to occupy

			// Step forward for next slot
			imageID = (H + probeCount * probeCount) % 1000;

			if (probeCount == 10)
			{
				__debugbreak();	// This shouldn't appen during normal use(i.e. the user isn't using too many textures
			}

			continue;
		}
		// THe slot is occupied and that is us
		else
		{
			// Increate reference count
			textureSlots[imageID].referenceCount++;

			// Return the GLuint objec
			return textureSlots[imageID].textureObject;
		}
	}

	// This location should never be reached since we assert the loop won't run over 10 interations
	__debugbreak();
	return 1U;	// We return the first texture object rather than openGL default 0, because 0 is black and 1 might make things more obviously wrong
}

void MaterialTextures::ReturnTexture(const char* texturePath)
{
	// Get the hashed ID of the image path
	unsigned int imageID = Hash::HashID((unsigned char*)texturePath, 1000);
	unsigned int H = imageID;

	// We search untill we reach where we are stored
	for (unsigned int probeCount = 1; probeCount <= 10; probeCount++)
	{
		// If the slot is occupied and it was us, then dereference it once
		if (textureSlots[imageID].textureObject != 0)
		{
			if (strcmp(textureSlots[imageID].originalPath, texturePath) == 0)
			{
				// Decrese Reference Count
				textureSlots[imageID].referenceCount--;

				// If Reference Count is zero now, delete the resource and set it to 0
				if (textureSlots[imageID].referenceCount == 0)
				{
					glDeleteTextures(1, &(textureSlots[imageID].textureObject));
					textureSlots[imageID].textureObject = 0;

					// Also delete the allocatdd memory
					delete textureSlots[imageID].originalPath;
					textureSlots[imageID].originalPath = NULL;
				}
			}
			// If the occupant isn't us, proceed
			else
			{
				imageID = (H + probeCount * probeCount) % 1000;

				if (probeCount == 10)
				{
					__debugbreak();	// This shouldn't appen during normal use(i.e. the user isn't using too many textures
				}
			}
		}
		// Otherwise it is not occupied, which indicate an unbalanced call, or the slot was occupied but then released
		else
		{
			//std::cout << "[Error]Error detected when try to return texture: the texture doesn't exist yet(This error indicates an unbalanced call)!" << std::endl;
			//__debugbreak();
		}
	}
}